<p class="page-title">Transparent Content Negotiation</p>

<div class="content-text">
  <div class="usecase-part">
    <div class="title-header-container">
      <span class="title-header">Description</span>
    </div>
    <span> </span>
  </div>
  <hr />
  <div class="page-part">
    <div class="title-header-container">
      <span class="title-header">Example</span>
    </div>
    <span>
      <ul>
        <li></li>
        <li></li>
      </ul>
    </span>
  </div>
  <hr />
  <div class="page-part">
    <div class="title-header-container">
      <span class="title-header">Use cases</span>
    </div>
    <span>
      <ul>
        <a routerLink="/usecase/mfml"></a>
      </ul>
    </span>
  </div>
  <hr />
  <div class="page-part">
    <div class="title-header-container">
      <span class="title-header">Advantages and Disadvantages</span>
    </div>
    <table>
      <thead>
        <tr>
          <th>Advantages</th>
          <th>Disadvantages</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <ul>
              <li>
                The cache is used to reduce the overhead on the server. The
                proxy can negotiate with clients because it knows how the server
                made the decision.
              </li>
            </ul>
          </td>
          <td>
            <ul>
              <li>
                We assume that most responses are reusable and not unique or private, otherwise caching is not applicable.
              </li>
            </ul>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
  <hr />

  <div class="reference-container">
    <div class="title-header-container">
      <span class="title-header">References</span>
    </div>
    <div *ngFor="let reference of references">
      <a routerLink="/reference" fragment="{{ reference.id }}" target="_blank"
        >[{{ reference.id }}]</a
      >
      : <span>{{ reference.title }}</span>
    </div>
  </div>
</div>
