<p class="page-title">Transparent Content Negotiation</p>

<div class="content-text">
  <div class="usecase-part">
    <div class="title-header-container">
      <span class="title-header">Description</span>
    </div>
    <div>
      <p>
        Transparent content negotiation is called "transparent" because it makes
        visible to the intermediate parties (between the origin server and the
        user agent e.g. proxy cache) all the variants that exist within the origin server and
        gives them the ability to choose the best representation on their
        behalf. Transparent content negotiation is a combination of proactive
        and reactive content negotiation. In reactive content negotiation, when
        a cache is provided in the form of a list of available representations
        of the response and the intermediate party has fully understood the
        dimensions of the variance, then the intermediate party becomes capable
        of performing proactive content negotiation on behalf of the origin
        server for subsequent requests on that resource.
      </p>
      <p>
        Optimization of content negotiation could be achieved for example as
        explained below:
      </p>
      <p>Scenario 0 - without transparent content negotiation:</p>
      <div>
        <img
          src="./assets/img/STransparent_S0.PNG"
          alt="Scenario 0"
          width="100%"
        />
      </div>
      <p>
        Scenario 1 - if the intermediary parties cache both variant lists and
        variants:
      </p>
      <div>
        <img
          src="./assets/img/STransparent_S1.PNG"
          alt="Scenario 1"
          width="100%"
        />
      </div>
      <p>
        Scenario 2 - the user agent can send small Accept- headers that contain
        enough information to allow the server to choose the best variant using
        a "remote variant selection algorithm", this possibility is made
        explicit in the "Negotiate" request header:
      </p>
      <div>
        <img
          src="./assets/img/STransparent_S2.PNG"
          alt="Scenario 2"
          width="100%"
        />
      </div>
      <p>
        Scenario 3 - If we combine the above two scenarios and assume that the
        user agent sends Accept- headers that contain enough information and
        allow intermediate parties to choose the best variant, this optimization
        scenario is achieved:
      </p>
      <div>
        <img
          src="./assets/img/STransparent_S3.PNG"
          alt="Scenario 3"
          width="100%"
        />
      </div>
    </div>
    <hr />
    <!-- <div class="page-part">
      <div class="title-header-container">
        <span class="title-header">Example</span>
      </div>
      <span>
        <ul>
          <li></li>
          <li></li>
        </ul>
      </span>
    </div>
    <hr /> -->
    <!-- <div class="page-part">
      <div class="title-header-container">
        <span class="title-header">Use cases</span>
      </div>
      <span>
        <ul>
          <a routerLink="/usecase/mfml"></a>
        </ul>
      </span>
    </div>
    <hr /> -->
    <div class="page-part">
      <div class="title-header-container">
        <span class="title-header">Advantages and Disadvantages</span>
      </div>
      <table>
        <thead>
          <tr>
            <th>Advantages</th>
            <th>Disadvantages</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <ul>
                <li>
                  The reduction of response time and bandwidth consumption due
                  to the distribution of the negotiation work that would
                  otherwise be required of the origin server.
                </li>
                <li>
                  The gain of the second request delay of reactive negotiation
                  when intermediary party uses the cache to be able to correctly
                  guess the right response.
                </li>
              </ul>
            </td>
            <td>
              <ul>
                <li>
                  The underlined assumption of maximum resource cachability
                  which in practice is only true for static and Unencrypted
                  content, implying that it would not be cost effective in
                  contexts where transmissions are cyphered.
                </li>
              </ul>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <hr />

    <div class="reference-container">
      <div class="title-header-container">
        <span class="title-header">References</span>
      </div>
      <div *ngFor="let reference of references">
        <a routerLink="/reference" fragment="{{ reference.id }}" target="_blank"
          >[{{ reference.id }}]</a
        >
        : <span>{{ reference.title }}</span>
      </div>
    </div>
  </div>
</div>
